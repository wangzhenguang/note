

### java并发机制的底层实现原理


cpu的术语定义

|术语 | 英文单词 | 描述|
|----|------|-------|
内存屏障 | memory barriers | 一组处理器指令，用于实现对内存操作的顺序限制
缓冲行 | cache line | cpu高速缓存中可以分配的最小储存单位。
原子操作 | atomic operations | 不可中断的一个或一系列操作
缓存行填充 | cache line fill | 当处理器识别到内存中读取操作是课缓存的，处理器读取整个高速缓存行到适当的缓存（l1,l2,l3的或所有）
缓存命中 | cache hit | 如果进行高速缓存行填充的内存位置仍然是下次处理器访问地址时，处理器从缓存中读取操作数，而不是从内存中读取。
写命中 | write hit | 当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回缓存，而不是写回到内存。
写缺失 | write misses the cache | 一个有效的缓存被写入到不存在的内存区域 


#### java内存模型

> java中，所有实例域、静态域和数组元素都存储在堆内存中。堆内存在线程之间共享。局部变量，方法定义参数，异常处理器不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。


volatile的内存语义
---

volatile变量具有以下特性
- 可见性。对一个volatile变量的读，总是能看到对这个volatile变量最后的写入。
- 原子性。对任意单个volatile变量的读、写都具有原子性，但类似于volatile++这种符合操作不具有原子性。


volatile 读、写的内存语义
- 当读一个volatile变量时。jmm会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。
- 线程a写一个volatile变量，实质上是线程a向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做的修改的）消息。
- 线程b读一个volatile变量，实质上是线程b接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做的修改的）消息。
- 线程a写一个volatile变量，随后线程b读这个volatile变量，这个过程实质上是线程a通过主内存向线程b发送消息。


