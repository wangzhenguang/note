
[TOC] 




### 1.1 编译原理

尽管通常将javaScript归类为'动态'或 '解释执行'语言,但事实上它是一门编译语言.这个事实对你来说可能显而易见,也可能你闻所未闻,取决于你接触过多少编程语言,具有多少经验.但与传统的编译语言不同,他不是提前编译的,编译结果也不能在分布式系统中进行移植.




尽管如此,JavaScript引擎进行编译的步骤和传统的编译语言非常相似,在某些环节可能比预想的要复杂. 




在传统编译语言的流程中,程序中的一段源码在执行之前会经历三个步骤,统称为'编译'.




- 分词/词法分析(Tokenizing/Lexing)

    这个过程会将由字符组成的字符串分解成(对编程语言来说) 有意义的代码块,这些代码块被称为词法单元(token) .例如,考虑程序var  a = 2;. 这段程序通常会被分解成为下面这些词法单元: var、a、 = 、 2、；。空格是否会被当做词法单元，取决于空格在这门语言中是否具有意义。





`分词（tokenizing)和词法分析（Lexing)之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断a是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那个这个过程就被称为词法分析。`




- 解析/语法分析（Parsing）

    这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract syntax Tree, AST)。


var a = 2;的抽象语法书中可能会有一个叫做VariableDeclaration的顶级节点，接下来是一个叫做Identifier(它的值是a) 的子节点，以及一个叫做AssignmentExpression的子节点。AssignmentExpression节点有一个叫做NumericLiteral(它的值是2）的子节点。




- 代码生成

将AST转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。

抛开具体细节，简单来说就是有某种方法可以将var a = 2;的AST转化为一组机器指令，用来创建一个叫做a的变量（包括分配内存等）,并将一个值储存在a中。




`关于引擎如何管理系统资源超出了我们的讨论范围，因此只需要简单地了解引擎可以根据需要创建并储存变量即可。`




比起那些编译过程只有三个步骤的语言的编译器，JavaScript引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。




因此在这里只进行宏观，简单的介绍，接下来你会发现我们介绍的这些看起来有点高深的内容与所要讨论的事情有什么关联。




首先，JavaScript引擎不会有大量的(像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不通，JavaScript的编译过程不是发生在构建之前的。




对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。在我们所要讨论的作用域背后，JavaScript引擎用尽了各种办法（比如JIT，可以延迟编译甚至实施重新编译）来保证性能最佳。




简单来说，任何JavaScript代码片段在执行前都需要进行编译（通常就在执行前）。因此，JavaScript编译器首先会对var a = 2；这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。




### 1.2 理解作用域



#### 1.2.1 演员表



首先介绍将要参与到对程序 var a = 2；进行处理的过程中的演员们，这样才能理解接下来将要的听到的对话。

- 引擎

从头到尾负责整个JavaScript程序的编译及执行过程。




- 编译器

引擎的好朋友之一，负责语法分析及代码生成等脏活累活。




- 作用域

引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。




为了能够完全理解JavaScript的工作原理，你需要开始像引擎（和他的朋友们）一样思考，从他们的角度提出问题，并从它们的角度回答这些问题。




### 1.2.2 对话

当你看见var = 2；这段程序时，很可能认为这是一句声明。但我们的新朋友引擎却不这么看。事实上，引擎认为这里有两个完全不同的声明，一个有编译器在编译时处理，另一个则有引擎在运行时处理。




下面我们将var a = 2；分解，看看引擎和它的朋友们是如何协同工作的。




编译器首先将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。




可以合理的假设编译器所产生的代码能够用下面的伪代码进行概括：“为一个变量非配内存，将其命名为a，然后将值2保存进这个变量。”然而，这并不完全正确。




事实上编译器会进行如下处理。

1. 遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。




2. 接下来编译器会为引擎生成运行时所需的代码，这写代码被用来处理a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。




如果引擎最终找到了a变量，就会将2赋值给它。否则引擎就会举手示意并抛出一个异常！




**总结：**变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。




### 1.2.3 编译器有话说

 为了进一步理解，我们需要多介绍一点编译器的术语。




编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量a来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。




在我们的例子中，引擎会为变量a进行LHS查询。另外一个查找的类型叫做RHS。

我打赌你一定能猜到“L” 和 “R”的含义，它们分别代表左侧和右侧。




什么东西的左侧和右侧？ 是一个赋值操作的左侧和右侧。




换句话说，当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。

讲的更准确一点，RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。




你可以将RHS理解为（取到它的源值），这意味着“得到某某的值”。




让我们继续深入研究。

考虑以下代码：

    console.log（a）；

其中对a的引用时一个RHS引用，因为这里a并没有赋予任何值。相应地，需要查找并取得a的值，这样才能将值传递给console.log(...)。




相比之下，例如：

    a = 2;





这里对a的引用则是LHS引用，因为实际上我们并不关心当前的值是什么，只是想要为=2这个赋值操作找到目标。